#+LaTeXT_CLASS: my-article
#+Title: Decorations for Affine Arithmetic
#+LATEX_HEADER: \usepackage{amsmath,amsfonts,amssymb}


* Introduction
~YalAA~ \cite{yalaa} is a library for implementing affine arithmetic (AA). The
library allows the user to plug in various policies for handling errors occurring
during the calculation through a user defined ~ErrorPolicy~. In this paper we
consider the use of decorations, a concept that came up recently during the
standardization process for interval arithmetic (IEEE P1788)
\cite{p1788motion8}, \cite{p1788motion18}, \cite{hayes2010},
\cite{p1788hayes2011}, \cite{kreinovich2011}, for error handling in ~YalAA~
. In the remaining sections we assume that the reader is familiar with the
decoration concept for intervals.

* Decorations

** Affine Decorations
The ~YalAA~'s ~ErrorPolDec~ policy class provides two types of decorations. Decorations
directly associated with function graph are called /F-decoration/. They make
claims about the function /f/ independently of the used implementation. If a
decoration is also dependent on the implementation it's called a
/C-decoration/. \\ Supported /F-decorations/:
+ $\mathrm{D}(f,X)$: ~tetrit~, function /f/ is defined over /X/
+ $\mathrm{CD}(f,X)$ ~bool~, function /f/ is continuous and defined over /X/
+ $\mathrm{BD}(f,X)$: ~bool~, function /f/ is bounded and defined over /X/
Supported /C-decorations/:
+ $\mathrm{VR}(f,X,\mathtt{aff\_t})$: ~bool~, /f/ has a valid range over /X/
  in the current implementation ($\mathrm{B}(f,X) \land \lnot \mathtt{Overflow}
  \land \lnot \mathrm{NE}$)
+ $\mathrm{NE}(f,X,\mathtt{aff\_t})$: ~bool~, no internal error occurred
$\mathrm{B}(f,X)$ denotes that the function is /bounded/ over the intersection
of its natural domain with /X/.

#Intentionally left out is the continuous flag:
#+ $C(f,X)$: bool, function /f/ is continuous and defined over /X/
** Current Status in P1788
The P1788 standard is still under heavy discussion. However, the following aspects
of exception handling have been already voted on. 
+ Use of decorations (Motion 8) \cite{p1788motion8}
+ Domain tetrit (Motion 18) \cite{p1788motion18}
While both motions have some ideas for specific decorations, their only
definite decision are the use of decoration and the domain tetrit. Some more
details are given in the position paper \cite{hayes2010}. Besides, the author proposes
two further decorations:
+ Defined and Continuous $\mathrm{CD}(f,X)$
+ Defined and Bounded $\mathrm{BD}(f,X)$
Both are combined into a single decoration $\mathrm{CB}(f,X) =
\mathrm{CD}(f,X) \land \mathrm{BD}(f,X)$.  However, the bounded decoration is
left out and only $C(f,X)$ is considered in a motion currently under
discussion by the same author\cite{p1788hayes2011}.

** Discussion
The F-decorations are consistent with the decoration definition considered by
the P1788 working group. The /domain tetrit/ $\mathrm{D}(f,X)$ is defined as
for IA in \cite{p1788motion18} and the /continuous and defined/ flag
$\mathrm{CD}(f,X)$ as described in \cite{p1788hayes2011}.  Furthermore, we
provide the $\mathrm{BD}(f,X)$ decorations meaning /bounded and defined/
\cite{hayes2010}.  Note that the considerations in \cite{p1788hayes2011}
regarding the bounded flag[fn:1] are not relevant in the affine context.

The C-decorations not only depend on the function $f$ and the affine form $X$
but also on the specific arithmetic implementation[fn:6].  ~YalAA~ allows the
user to detect overflows during computation through the
$\mathrm{VR}(f,X,\mathtt{aff\_t})$ decoration. Furthermore, an /internal error/
flag $\mathrm{NE}(f,X,\mathtt{aff\_t})$ is used for signaling an unexpected
failure during the computation. We would like to point out that both flags
make /no/ claims on the function /f/ but on its implementation.

* Possible Combinations
Per definition we have the relationships
+ $\mathrm{CD} \rightarrow \mathrm{D}^+ \land \lnot \mathrm{D}^- \lor \lnot(\mathrm{D}^+ \lor \mathrm{D}^-)$
+ $\mathrm{BD} \rightarrow \mathrm{D}^+ \land \lnot \mathrm{D}^- \lor \lnot(\mathrm{D}^+ \lor \mathrm{D}^-)$
between F-decorations[fn:2]. Furthermore, we can deduce:
+ $\mathrm{CD} \rightarrow \mathrm{BD}$ ("every continuous function over an closed set is bounded")
This leads to the possible combinations:
|----------------+----------------+----+----+----------------|
| $\mathrm{D}^+$ | $\mathrm{D}^-$ | CD | BD | Dec.           |
|----------------+----------------+----+----+----------------|
| F              | F              | T  | T  | $\mathbb{D}_5$ |
| T              | F              | T  | T  | $\mathbb{D}_4$ |
| T              | F              | F  | T  | $\mathbb{D}_3$ |
| T              | F              | F  | F  | $\mathbb{D}_2$ |
| T              | T              | F  | F  | $\mathbb{D}_1$ |
| F              | T              | F  | F  | $\mathbb{D}_0$ |
|----------------+----------------+----+----+----------------|

The valid range flag is linked with the bounded property B, the domain tetrit
D and the general error flag NE:
+ $\lnot B \rightarrow \lnot VR$
+ $\lnot D^+ \rightarrow  \lnot VR$
+ $\lnot NE \rightarrow \lnot VR$
This results in the following possible combinations:
|----------------+-----+----+----+----------|
| $\mathrm{D}^+$ | (B) | VR | NE |  No.  |
|----------------+-----+----+----+----------|
| T              | T   | T  | T  |        1 |
| T              | T   | F  | T  |        2 |
| T              | F   | F  | T  |        3 |
| F              | ?   | F  | T  |        4 |
| ?              | ?   | F  | F  |        5 |
|----------------+-----+----+----+----------|
For the user the cases two and three are identically because the bounded flag
is invisible to him. Case 4 is same as either F-decoration $\mathbb{D}_0$ or
$\mathbb{D}_5$.  The /internal error/ flag NE is a special case. If
$\mathrm{NE}$ is false, all other flags are in an undefined state with the
exception of VR which is also false in this case.  This convention allows
checking only the VR flag in order to detect whether the computation was
error-free and the affine part has a meaningful value.

* Meanings
  The F-decorations make claims about the function /f/ over /X/:
|----------------+-----------------------------------------------------------|
| Dec            | Description                                               |
|----------------+-----------------------------------------------------------|
| $\mathbb{D}_5$ | /X/ is the empty set                                      |
| $\mathbb{D}_4$ | /f/ is certainly defined, continuous and bounded over /X/ |
| $\mathbb{D}_3$ | /f/ is certainly defined bounded over /X/                 |
| $\mathbb{D}_2$ | /f/ is certainly defined and unbounded over /X/           |
| $\mathbb{D}_1$ | /f/ is possibly defined over /X/                          |
| $\mathbb{D}_0$ | /f/ is certainly undefined over /X/                       |
|----------------+-----------------------------------------------------------|
  Just like their archetypes in \cite{p1788hayes2011}, \cite{hayes2010} they are
  ordered: $$ \mathbb{D}_0 < \mathbb{D}_1 < \mathbb{D}_ 2 < \mathbb{D}_3 <
  \mathbb{D}_4 < \mathbb{D}_5$$ by their quality. If a computation yields
  $\mathbb{D}_i$ over $X$, it is guaranteed that the same computation over some
  subbox $X' \subseteq X$ yields a decorations $\mathbb{D}_j$ with $j \geq i$. 
  ~ErrorPolDec~ supports property tracking as defined in
  \cite{p1788hayes2011}, Def. 3. 
It is also possible to interpret the C-decorations:
|------+----------------------------------|
| Dec. | Description                      |
|------+----------------------------------|
|    1 | No errors during calculation     |
|  2/3 | Unbounded and/or Overflow        |
|    4 | $\mathbb{D}_0$ or $\mathbb{D}_5$ |
|    5 | Internal error                   |
|------+----------------------------------|

* Mapping to Standard Affine Arithmetic
  AA as described by de Figueiredo and Stolfi \cite{stolfi1997} provides two
  special values for error handling:
  + *R* denoting the whole real line
  + *[]* denoting the empty affine form (set)
We define the following mapping from the decorations to these special values:
|--------------------------------+---------------|
| Dec.                           | Special Value |
|--------------------------------+---------------|
| $\mathbb{D}_5, \mathbb{D}_0$   | *[]*          |
| $\mathbb{D}_2, \mathfrak{D}_1$ | *R*           |
|--------------------------------+---------------|
| $\mathfrak{D}_0$               | *[]*          |
|--------------------------------+---------------|
This maps all error conditions to their respective counterparts in the affine
model. Mapping $\mathfrak{D}_0$ to *[]* might look a bit controverse at the
first glance. However, as the special values refer to both the mathematical
function and the implementation[fn:3] we can interpret $\mathfrak{D}_0$ as if
the implementation is not defined over /X/. 

* Interoperability with IA
** Combination with IA
Affine forms can combined with interval using addition, subtraction, ... . As
the proposed affine decorations mainly follow the decorations under discussion
for intervals, ~YalAA~ aims at providing proper property tracking for mixed
calculation. However, specific details depend on the final P1788 standard and
concrete implementation of decorations in IA libraries.
** Conversion to IA
All special functions which can produce some error state are implemented
through non-affine approximations over an interval enclosure of the affine
form. That is, the decoration part of an affine form can propagated to a
decorated interval without loss of correctness.

* Implementation
** Data Types
Following the original approach of \cite{stolfi1997} every affine form in
~YalAA~ has a field to store whether the form has a special value. Its type is
determined by the used ~ErrorPolicy~ \cite{yalaa}. ~ErrorPolDec~ defines this
type to ~unsigned short~. The F- and C-decorations are stored
separately. While the first three bits store the F-decoration in form of the
$\mathbb{D}_i, 0 \leq i \leq 5$ defined above, the following two store the
negated VR and the NE flags separately.
** Limits
Because decorated interval are up to today not supported by interval
libraries, the interoperability is not implemented in ~YalAA~. The
~ErrorPolDec~ class is subject to change whereas P1788 evolves.


\bibliographystyle{plain}
\bibliography{references}


* Footnotes

[fn:1] Currently it is discussed if unbounded intervals can be represented by
using $\infty$ in interval bounds. However, as there is currently
no distinction between /real infinities/ and overflows in IEEE754, either one
of these cases has to be a decoration or an additional infinity value is to
be added for distinction of these cases.

[fn:6] in ~YalAA~ especially on the used types for partial deviations and policies

[fn:2] Following \cite{p1788hayes2011} functions are per definition continuous and bounded over the empty set.

[fn:3] R is used for indicating overflows in \cite{stolfi1997}.


